# Calculus notebook

## Section

```elixir
  Mix.install([
      {:axon, "~> 0.6.1"},
      {:nx, "~> 0.7.3"},
      {:exla, "~> 0.7.3"},
      {:bumblebee, "~> 0.5.3"},
      {:explorer, "~> 0.9.1"},
      {:kino, "~> 0.13.2"},
      {:kino_vega_lite, "~> 0.1.13"},
      {:vega_lite, "~> 0.1.9"},
      {:tucan, "~> 0.3.0"},
      {:stb_image, "~> 0.6.9"},
      {:benchee, "~> 1.3"},
      {:ecto, "~> 3.12"}
  ],
  config: [
    nx: [
      default_backend: EXLA.Backend,
      default_defn_options: [compiler: EXLA]
    ]
  ]
  )

```

```elixir
alias VegaLite, as: Vl

x = Nx.linspace(-10, 10, n: 100_000)
y = Nx.add(Nx.add(Nx.pow(x, 2), Nx.multiply(2, x)), 2)
data = [ x: x, y: y ]

Tucan.lineplot(data, "x", "y", tooltip: true)
|> Tucan.set_title("Calculus Limits")
```

```elixir
in_domain = fn (min, max) -> fn (x) -> x <= max && x >= min end end

flist_filter = fn (t, filter_pred) ->
  t
  |> Nx.to_flat_list()
  |> Enum.filter(filter_pred)
end

[
  x: flist_filter.(x, in_domain.(-2, 0)),
  y: flist_filter.(y, in_domain.(0, 2))
]
|> Tucan.lineplot("x", "y", tooltip: true)
|> Tucan.set_title("Calculus Limits; (-2, 0), (0, 2)")
```

```elixir
[
  x: flist_filter.(x, in_domain.(-1.5, -0.5)),
  y: flist_filter.(y, in_domain.(0.5, 1.5))
]
|> Tucan.lineplot("x", "y", tooltip: true)
|> Tucan.set_title("Calculus Limits; (-1.5, -0.5), (0.5, 1.5)")
```

```elixir
[
  x: flist_filter.(x, in_domain.(-1.1, -0.9)),
  y: flist_filter.(y, in_domain.(0.9, 1.1))
]
|> Tucan.lineplot("x", "y", tooltip: true)
|> Tucan.set_title("Calculus Limits; (-1.1, -0.9), (0.9, 1.1)")

```

```elixir
[
  x: flist_filter.(x, in_domain.(-1.01, -0.99)),
  y: flist_filter.(y, in_domain.(0.99, 1.01))
]
|> Tucan.lineplot("x", "y", tooltip: true)
|> Tucan.set_title("Calculus Limits; (-1.01, -0.99), (0.99, 1.01)")

```

```elixir
"""
RFC 4122                  A UUID URN Namespace                 July 2005
   4.1.2.  Layout and Byte Order

   To minimize confusion about bit assignments within octets, the UUID
   record definition is defined only in terms of fields that are
   integral numbers of octets.  The fields are presented with the most
   significant one first.

   Field                  Data Type     Octet  Note
                                        #

   time_low               unsigned 32   0-3    The low field of the
                          bit integer          timestamp

   time_mid               unsigned 16   4-5    The middle field of the
                          bit integer          timestamp

   time_hi_and_version    unsigned 16   6-7    The high field of the
                          bit integer          timestamp multiplexed
                                               with the version number
   clock_seq_hi_and_rese  unsigned 8    8      The high field of the
   rved                   bit integer          clock sequence
                                               multiplexed with the
                                               variant

   clock_seq_low          unsigned 8    9      The low field of the
                          bit integer          clock sequence

   node                   unsigned 48   10-15  The spatially unique
                          bit integer          node identifier

   In the absence of explicit application or presentation protocol
   specification to the contrary, a UUID is encoded as a 128-bit object,
   as follows:

   The fields are encoded as 16 octets, with the sizes and order of the
   fields defined above, and with each field encoded with the Most
   Significant Byte first (known as network byte order).  Note that the
   field names, particularly for multiplexed fields, follow historical
   practice.

   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

4.1.3.  Version

   The version number is in the most significant 4 bits of the time
   stamp (bits 4 through 7 of the time_hi_and_version field).

   The following table lists the currently-defined versions for this
   UUID variant.

   Msb0  Msb1  Msb2  Msb3   Version  Description

    0     0     0     1        1     The time-based version
                                     specified in this document.

    0     0     1     0        2     DCE Security version, with
                                     embedded POSIX UIDs.


    0     0     1     1        3     The name-based version
                                     specified in this document
                                     that uses MD5 hashing.

->  0     1     0     0        4     The randomly or pseudo- 
                                     randomly generated version
                                     specified in this document.

    0     1     0     1        5     The name-based version
                                     specified in this document
                                     that uses SHA-1 hashing.

   The version is more accurately a sub-type; again, we retain the term
   for compatibility.

Leach, et al.               Standards Track                     [Page 7]
"""
```

```elixir
# V4 UUID alt implemention
defmodule Pkl.UUID do
  @moduledoc """
  [RFC-4122](https://datatracker.ietf.org/doc/html/rfc4122)
  4.4.  Algorithms for Creating a UUID from Truly Random or
      Pseudo-Random Numbers

   The version 4 UUID is meant for generating UUIDs from truly-random or
   pseudo-random numbers.

   The algorithm is as follows:

   o  Set the two most significant bits (bits 6 and 7) of the
      clock_seq_hi_and_reserved to zero and one, respectively.

   o  Set the four most significant bits (bits 12 through 15) of the
      time_hi_and_version field to the 4-bit version number from
      Section 4.1.3.

   o  Set all the other bits to randomly (or pseudo-randomly) chosen
      values.
  """
  def gen_v4 do
    {uuid, _} = for <<n::4 <- :crypto.strong_rand_bytes(16)>>, reduce: {"", 0} do
      {bits, write_idx} ->
        out_str = case write_idx do
          12 -> "-4" # 4bit '0 1 0 0 ' version :time_hi_and_version
          16 -> "-2" # 4bit '0 0 1 0' :clock_seq_hi_and_reserved
          i when i in [8, 20, 32] -> "-#{Integer.to_string(n, 16)}"
          _ -> Integer.to_string(n, 16)
        end
        {Enum.join([bits, out_str]), write_idx + 1}
      end
    uuid
  end
end
```

```elixir
uuid = Pkl.UUID.gen_v4()
|> IO.inspect()
Ecto.UUID.cast(uuid)
```
